@page "/household/{Code}"
@using Microsoft.AspNetCore.Components
@using WG_Chores.Data
@using WG_Chores.Services
@using System.Linq
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@inject IHouseholdService HouseholdService
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject AppPreferencesService Preferences
@implements IDisposable

<PageTitle>Household</PageTitle>

<div class="household-page">
    @if (loading)
    {
        <div class="household-loading">
            <div class="spinner" aria-hidden="true"></div>
            <p>Loading...</p>
        </div>
    }
    else if (household == null)
    {
        <div class="household-empty">
            <p class="household-empty-text">Household not found.</p>
            <button class="btn btn-outline-secondary" @onclick="GoHome">Back to login</button>
        </div>
    }
    else
    {
        <div class="household-toolbar">
            <button class="btn btn-outline-secondary household-sort-btn" type="button" @onclick="ToggleSortMenu" title="Sort">
                <i class="fa-solid fa-arrow-down-wide-short" aria-hidden="true"></i>
                <span>@(sortMode == SortMode.Category ? "Category" : "Time")</span>
            </button>
            <button class="household-add-btn btn btn-outline-secondary" type="button" @onclick="OpenAddModal" title="Add chore" aria-label="Add chore">
                <i class="fa-solid fa-plus" aria-hidden="true"></i>
                Add Chore
            </button>
            @if (showSortMenu)
            {
                <div class="household-sort-overlay" @onclick="ToggleSortMenu"></div>
                <div class="household-sort-menu">
                    <button type="button" class="household-sort-item @(sortMode == SortMode.Category ? "active" : "")" @onclick="() => SetCategorySort()">Category</button>
                    <button type="button" class="household-sort-item @(sortMode == SortMode.Time ? "active" : "")" @onclick="() => SetTimeSort()">
                        Time @((sortMode == SortMode.Time) ? (timeAsc ? "↑" : "↓") : "")
                    </button>
                </div>
            }
        </div>

        @if (household.Chores == null || !household.Chores.Any())
        {
            <div class="household-empty-state">
                <i class="fa-solid fa-broom" aria-hidden="true"></i>
                <p>No chores yet.</p>
            </div>
        }
        else
        {
            <div class="household-chores">
                @if (sortMode == SortMode.Category)
                {
                    var groups = household.Chores
                        .GroupBy(c => string.IsNullOrWhiteSpace(c.Room) ? "General" : c.Room)
                        .OrderBy(g => g.Key);

                    foreach (var grp in groups)
                    {
                        <section class="chore-section">
                            <h2 class="chore-section-title">@grp.Key</h2>
                            <ul class="chore-list">
                                @foreach (var c in grp.OrderBy(x => x.Title))
                                {
                                    <li class="chore-item" @onclick="() => OnChoreClick(c)">
                                        <span class="chore-title">@c.Title</span>
                                        <span class="chore-meta">
                                            @if (Preferences.ShowMemberNames)
                                            {
                                                <span class="chore-meta-member">@GetLastCompletedMember(c.Id)</span>
                                            }
                                            <span class="chore-meta-date">@GetLastCompletedText(c.Id)</span>
                                        </span>
                                    </li>
                                }
                            </ul>
                        </section>
                    }
                }
                else
                {
                    var ordered = timeAsc
                        ? household.Chores.OrderBy(c => GetChoreDoneAt(c.Id))
                        : household.Chores.OrderByDescending(c => GetChoreDoneAt(c.Id));

                    <ul class="chore-list chore-list-flat">
                        @foreach (var c in ordered)
                        {
                            <li class="chore-item" @onclick="() => OnChoreClick(c)">
                                <div>
                                    <span class="chore-title">@c.Title</span>
                                    @if (!string.IsNullOrWhiteSpace(c.Room))
                                    {
                                        <span class="chore-room">@c.Room</span>
                                    }
                                </div>
                                <span class="chore-meta">
                                    @if (Preferences.ShowMemberNames)
                                    {
                                        <span class="chore-meta-member">@GetLastCompletedMember(c.Id)</span>
                                    }
                                    <span class="chore-meta-date">@GetLastCompletedText(c.Id)</span>
                                </span>
                            </li>
                        }
                    </ul>
                }
            </div>
        }
    }
</div>

@if (showAddModal)
{
    <div class="modal-backdrop @(isAddModalClosing ? "modal-backdrop-closing" : "")" @onclick="CloseAddModalAsync"></div>
    <div class="chore-modal" @onclick="CloseAddModalAsync">
        <div class="chore-modal-sheet @(isAddModalClosing ? "chore-modal-sheet-closing" : "")" @onclick:stopPropagation="true">
            <div class="chore-modal-header">
                <h3>@(editingChore != null ? "Edit chore" : "Add chore")</h3>
                <button type="button" class="chore-modal-close" @onclick="CloseAddModalAsync" aria-label="Close">✕</button>
            </div>
            <div class="chore-modal-body">
                <div class="form-floating mb-3">
                    <input class="form-control" id="chore-title" placeholder="Chore name" @bind="newChoreTitle" />
                    <label for="chore-title">Chore name</label>
                </div>
                <div class="form-floating mb-3">
                    <input class="form-control" id="chore-room" placeholder="Room" @bind="newChoreRoom" />
                    <label for="chore-room">Room</label>
                </div>
                <div class="chore-modal-actions">
                    @if (editingChore != null)
                    {
                        <button class="btn btn-danger" @onclick="DeleteChoreAsync">Delete</button>
                    }
                    <button class="btn btn-outline-secondary" @onclick="CloseAddModalAsync">Cancel</button>
                    <button class="btn btn-primary" @onclick="SubmitAddChoreAsync" disabled="@string.IsNullOrWhiteSpace(newChoreTitle)">@(editingChore != null ? "Save" : "Add")</button>
                </div>
            </div>
        </div>
    </div>
}

@if (showConfirmModal && confirmChore != null)
{
    <div class="modal-backdrop @(isConfirmModalClosing ? "modal-backdrop-closing" : "")" @onclick="CloseConfirmModalAsync"></div>
    <div class="chore-modal" @onclick="CloseConfirmModalAsync">
        <div class="chore-modal-sheet chore-confirm-sheet @(isConfirmModalClosing ? "chore-modal-sheet-closing" : "")" @onclick:stopPropagation="true">
            <div class="chore-modal-header">
                <h3>@confirmChore.Title</h3>
                <button type="button" class="chore-modal-close" @onclick="CloseConfirmModalAsync" aria-label="Close">✕</button>
            </div>
            <div class="chore-modal-body">
                <div class="chore-confirm-date">
                    <label for="confirm-date">Date</label>
                    <input type="date" id="confirm-date" class="form-control" @bind="confirmDate" />
                </div>
                <div class="chore-confirm-actions">
                    <button class="btn btn-primary chore-confirm-mark-done" @onclick="ConfirmMarkDoneAsync">
                        <i class="fa-solid fa-check" aria-hidden="true"></i>
                        Mark done
                    </button>
                    <div class="chore-confirm-secondary">
                        <button class="btn btn-outline-secondary" @onclick="EditFromConfirm">
                            <i class="fa-solid fa-pen" aria-hidden="true"></i>
                            Edit
                        </button>
                        <button class="btn btn-outline-secondary" @onclick="CloseConfirmModalAsync">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public string? Code { get; set; }

    private WG_Chores.Data.Household? household;
    private bool loading = true;
    private bool showAddModal = false;
    private string newChoreTitle = string.Empty;
    private string newChoreRoom = string.Empty;
    private WG_Chores.Data.Chore? editingChore;
    private bool showConfirmModal = false;
    private bool isAddModalClosing = false;
    private bool isConfirmModalClosing = false;
    private WG_Chores.Data.Chore? confirmChore;
    private DateTime confirmDate = DateTime.Today;
    private Dictionary<int, (DateTime? DoneAt, string? MemberName)> lastDone = new();
    private int? currentMemberId;
    private string? currentMemberName;

    protected override void OnInitialized()
    {
        Preferences.OnShowMemberNamesChanged += StateHasChanged;
    }

    public void Dispose()
    {
        Preferences.OnShowMemberNamesChanged -= StateHasChanged;
    }

    protected override async Task OnParametersSetAsync()
    {
        await Load();
    }

    private async Task Load()
    {
        loading = true;
        if (string.IsNullOrWhiteSpace(Code))
        {
            household = null;
        }
        else
        {
            // Get basic household by code first
            var basic = await HouseholdService.GetByCodeAsync(Code!);
            if (basic == null)
            {
                household = null;
            }
            else
            {
                // Ensure chores (and members) are loaded by fetching the full household
                household = await HouseholdService.GetByIdAsync(basic.Id);
                // persist the last-opened household code in a cookie for convenience
                try { if (household != null) await JS.InvokeVoidAsync("wgChores.setCookie", "wg_household_code", household.Code, 365); } catch { }
            }
        }
        // load last done dates for chores
        lastDone.Clear();
        // load current member info from localStorage (if available)
        try
        {
            var idStr = await JS.InvokeAsync<string?>("wgChores.getCookie", "wg_member_id");
            if (int.TryParse(idStr, out var mid)) currentMemberId = mid;
            currentMemberName = await JS.InvokeAsync<string?>("wgChores.getCookie", "wg_member_username");
        }
        catch
        {
            currentMemberId = null;
            currentMemberName = null;
        }
        // sync preference from cookie (in case user navigated directly)
        try
        {
            var showStr = await JS.InvokeAsync<string?>("wgChores.getCookie", "wg_show_member_names");
            if (bool.TryParse(showStr, out var s)) Preferences.SetShowMemberNames(s);
        }
        catch { }
        if (household != null && household.Chores != null && household.Chores.Any())
        {
            var chores = household.Chores.ToList();
            var tasks = chores.Select(async c =>
            {
                try
                {
                    var hist = await HouseholdService.GetChoreHistoryAsync(c.Id);
                    var histSorted = hist.OrderByDescending(h => h.DoneAt);
                    var latestEntry = histSorted.FirstOrDefault();
                    lock (lastDone)
                    {
                        lastDone[c.Id] = (latestEntry?.DoneAt, latestEntry?.MemberName);
                    }
                }
                catch
                {
                    lock (lastDone) { lastDone[c.Id] = (null, null); }
                }
            }).ToArray();

            await Task.WhenAll(tasks);
        }
        loading = false;
        StateHasChanged();
    }

    private async Task Refresh() => await Load();

    private void GoHome() => Nav.NavigateTo("/");

    private void OpenAddModal()
    {
        newChoreTitle = string.Empty;
        newChoreRoom = string.Empty;
        editingChore = null;
        showAddModal = true;
    }

    private bool showSortMenu = false;
    private void ToggleSortMenu()
    {
        showSortMenu = !showSortMenu;
    }
    private enum SortMode { Category, Time }
    private SortMode sortMode = SortMode.Category;
    private bool timeAsc = true;

    private void SetCategorySort()
    {
        sortMode = SortMode.Category;
        showSortMenu = false;
    }

    private void SetTimeSort()
    {
        if (sortMode == SortMode.Time)
        {
            // toggle asc/desc
            timeAsc = !timeAsc;
        }
        else
        {
            sortMode = SortMode.Time;
            timeAsc = true; // default first press = ascending
        }
        showSortMenu = false;
    }

    private DateTime GetChoreDoneAt(int choreId)
    {
        if (lastDone.TryGetValue(choreId, out var entry) && entry.DoneAt.HasValue)
            return entry.DoneAt.Value.ToLocalTime();
        // treat never-done as very old so it appears first when sorting ascending
        return DateTime.MinValue;
    }

    // Date changes are handled by binding to `selectedDate` directly.

    private void OpenEditModal(WG_Chores.Data.Chore c)
    {
        editingChore = c;
        newChoreTitle = c.Title;
        newChoreRoom = c.Room ?? string.Empty;
        showAddModal = true;
    }

    private void OnChoreClick(WG_Chores.Data.Chore c)
    {
        confirmChore = c;
        confirmDate = DateTime.Today;
        confirmDate = confirmDate.Date + DateTime.Now.TimeOfDay;
        showConfirmModal = true;
    }

    private async Task EditFromConfirm()
    {
        if (confirmChore == null) return;
        var chore = confirmChore;
        await CloseConfirmModalAsync();
        OpenEditModal(chore);
    }

    private async Task CloseConfirmModalAsync()
    {
        if (isConfirmModalClosing) return;
        isConfirmModalClosing = true;
        StateHasChanged();
        await Task.Delay(250);
        showConfirmModal = false;
        confirmChore = null;
        isConfirmModalClosing = false;
    }

    private async Task ConfirmMarkDoneAsync()
    {
        if (confirmChore == null) return;

        try
        {
            var idStr = await JS.InvokeAsync<string?>("wgChores.getCookie", "wg_member_id");
            if (int.TryParse(idStr, out var mid)) currentMemberId = mid;
            currentMemberName = await JS.InvokeAsync<string?>("wgChores.getCookie", "wg_member_username");
        }
        catch
        {
            currentMemberId = null;
            currentMemberName = null;
        }

        if (currentMemberId == null && !string.IsNullOrWhiteSpace(currentMemberName) && household != null)
        {
            try
            {
                var member = await HouseholdService.JoinAsync(household.Code, currentMemberName);
                if (member != null)
                {
                    currentMemberId = member.Id;
                    currentMemberName = member.Username;
                    try { await JS.InvokeVoidAsync("wgChores.setCookie", "wg_member_id", member.Id.ToString(), 365); } catch { }
                }
            }
            catch { }
        }

        await HouseholdService.AddChoreHistoryAsync(confirmChore.Id, currentMemberId, currentMemberName, notes: null, doneAt: confirmDate);
        await CloseConfirmModalAsync();
        await Load();
    }

    private async Task CloseAddModalAsync()
    {
        if (isAddModalClosing) return;
        isAddModalClosing = true;
        StateHasChanged();
        await Task.Delay(250);
        showAddModal = false;
        editingChore = null;
        isAddModalClosing = false;
    }

    private async Task SubmitAddChoreAsync()
    {
        if (household == null) return;
        if (string.IsNullOrWhiteSpace(newChoreTitle)) return;

        if (editingChore != null)
        {
            // update existing chore
            var updated = new WG_Chores.Data.Chore
            {
                Id = editingChore.Id,
                Title = newChoreTitle.Trim(),
                Description = editingChore.Description,
                Room = string.IsNullOrWhiteSpace(newChoreRoom) ? null : newChoreRoom.Trim(),
                IsDone = editingChore.IsDone,
                HouseholdId = editingChore.HouseholdId,
                CreatedAt = editingChore.CreatedAt
            };
            await HouseholdService.UpdateChoreAsync(updated);
        }
        else
        {
            // Add chore to this household only
            await HouseholdService.AddChoreAsync(household.Id, newChoreTitle.Trim(), description: null, room: string.IsNullOrWhiteSpace(newChoreRoom) ? null : newChoreRoom.Trim());
        }

        await CloseAddModalAsync();
        await Load();
    }

    private async Task DeleteChoreAsync()
    {
        if (editingChore == null) return;
        await HouseholdService.RemoveChoreAsync(editingChore.Id);
        editingChore = null;
        await CloseAddModalAsync();
        await Load();
    }

    private string GetLastCompletedText(int choreId)
    {
        if (!lastDone.TryGetValue(choreId, out var entry) || entry.DoneAt == null)
            return "Never";

        var doneDate = entry.DoneAt.Value.ToLocalTime().Date;
        var today = DateTime.Today;
        var days = (today - doneDate).Days;
        if (days == 0) return "Today";
        if (days == 1) return "1 day ago";
        return $"{days} days ago";
    }

    private string GetLastCompletedMember(int choreId)
    {
        if (!lastDone.TryGetValue(choreId, out var entry) || entry.DoneAt == null)
            return string.Empty;

        return string.IsNullOrWhiteSpace(entry.MemberName) ? "Unknown" : entry.MemberName;
    }

}
